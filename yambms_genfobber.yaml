# CC1101 Fobber Component - YamBMS Remote Package Module
# This module sends RF commands to control a generator via CC1101 transceiver
# Include this file in your main ESPHome configuration
# Override pins and RF codes using vars: when including this package

# Configuration defaults - override via vars: in parent file
substitutions:
  # CC1101 Pin Configuration
  sck_pin: "18"           # SPI Clock
  miso_pin: "19"          # SPI MISO
  mosi_pin: "23"          # SPI MOSI
  csn_pin: "5"            # Chip Select
  gdo0_pin: "2"           # CC1101 GDO0 Data I/O
  dry_contact_pin: "15"   # Dry contact input
  # RF Transmission Settings
  tx_frequency: "433.89"  # TX frequency in MHz
  # Generator control RF codes - replace with your captured codes
  generator_start_code: '[339, -1161, 1071, -413, 1062, -423, 321, -1159, 330, -1144, 1064, -419, 324, -1171, 1064, -419, 1073, -413, 1062, -422, 319, -1163, 1055, -414, 1085, -419, 1068, -409, 336, -1145, 323, -1161, 1074, -413, 338, -1146, 319, -1165, 329, -1145, 337, -1158, 318, -1166, 335, -1146, 1073, -422, 327]'
  generator_stop_code: '[330, -1143, 1064, -419, 1075, -413, 337, -1150, 319, -1163, 1056, -433, 312, -1178, 1069, -408, 1061, -414, 1080, -417, 321, -1151, 1065, -421, 1067, -404, 1085, -406, 340, -1158, 321, -1150, 1061, -421, 319, -1165, 330, -1170, 302, -1182, 321, -1151, 334, -1146, 1067, -432, 334, -1146, 324]'

# Required includes and libraries
# For remote package use: C++ code embedded directly in lambda to avoid external file dependency
esphome:
  libraries:
    - SPI
    - "SmartRC-CC1101-Driver-Lib"
  on_boot:
    priority: 600  # Run early, before most other components
    then:
      - lambda: |-
          // https://github.com/dbuezas/esphome-cc1101
          // CC1101 class definition - embedded for remote package compatibility
          #include <ELECHOUSE_CC1101_SRC_DRV.h>
          #include "esphome/components/remote_transmitter/remote_transmitter.h"

          #ifndef CC1101TRANSCIVER_H
          #define CC1101TRANSCIVER_H

          static int CC1101_module_count = 0;
          #define get_cc1101(id) (*((CC1101*)id))

          class CC1101 : public PollingComponent, public Sensor {
            int _SCK;
            int _MISO;
            int _MOSI;
            int _CSN;
            int _GDO0;  // TX and also RX
            float _bandwidth;
            esphome::remote_transmitter::RemoteTransmitterComponent* _remote_transmitter;
            float _moduleNumber;
            int _last_rssi = 0;

            void setup() override {
              pinMode(_GDO0, INPUT);
              ELECHOUSE_cc1101.addSpiPin(_SCK, _MISO, _MOSI, _CSN, _moduleNumber);
              ELECHOUSE_cc1101.setModul(_moduleNumber);
              ELECHOUSE_cc1101.Init();
              ELECHOUSE_cc1101.setRxBW(_bandwidth);
              ELECHOUSE_cc1101.setMHZ(_freq);
              ELECHOUSE_cc1101.SetRx();
            }

           public:
            float _freq;
            CC1101(int SCK, int MISO, int MOSI, int CSN, int GDO0, float bandwidth, float freq,
                   esphome::remote_transmitter::RemoteTransmitterComponent* remote_transmitter)
                : PollingComponent(100) {
              _SCK = SCK;
              _MISO = MISO;
              _MOSI = MOSI;
              _CSN = CSN;
              _GDO0 = GDO0;
              _bandwidth = bandwidth;
              _freq = freq;
              _moduleNumber = CC1101_module_count++;
              _remote_transmitter = remote_transmitter;
            }

            void beginTransmission() {
              ELECHOUSE_cc1101.setModul(_moduleNumber);
              ELECHOUSE_cc1101.SetTx();
              pinMode(_GDO0, OUTPUT);
          #ifdef USE_ESP32
              _remote_transmitter->setup();
          #endif
          #ifdef USE_ESP8266
              noInterrupts();
          #endif
            }
            void endTransmission() {
              digitalWrite(_GDO0, 0);
              pinMode(_GDO0, INPUT);
          #ifdef USE_ESP8266
              interrupts();
          #endif
              ELECHOUSE_cc1101.setModul(_moduleNumber);
              ELECHOUSE_cc1101.SetRx();
              ELECHOUSE_cc1101.SetRx();  // yes, twice
            }
            void setBW(float bandwidth) {
              ELECHOUSE_cc1101.setModul(_moduleNumber);
              ELECHOUSE_cc1101.setRxBW(bandwidth);
            }
            void setFreq(float freq) {
              ELECHOUSE_cc1101.setModul(_moduleNumber);
              ELECHOUSE_cc1101.setMHZ(freq);
            }
            bool rssi_on = false;
            void update() override {
              int rssi = 0;
              if (rssi_on) {
                ELECHOUSE_cc1101.setModul(_moduleNumber);
                rssi = ELECHOUSE_cc1101.getRssi();
                if (rssi != _last_rssi) {
                  publish_state(rssi);
                  _last_rssi = rssi;
                }
              }
            }
          };

          #endif

          // Create and register CC1101 transceiver
          auto *cc1101 = new CC1101(
            ${sck_pin},   // SCK
            ${miso_pin},  // MISO
            ${mosi_pin},  // MOSI
            ${csn_pin},   // CSN
            ${gdo0_pin},  // GDO0
            200,  // bandwidth_khz
            ${tx_frequency}, // frequency_mhz
            id(transmitter)
          );
          App.register_component(cc1101);
          id(cc1101_transceiver) = cc1101;



# Internal globals for RF codes (populated from substitutions)
globals:
  - id: generator_start_code
    type: std::vector<int>
    initial_value: '${generator_start_code}'
  - id: generator_stop_code
    type: std::vector<int>
    initial_value: '${generator_stop_code}'
  - id: cc1101_transceiver
    type: CC1101*
    initial_value: 'nullptr'
    restore_value: no


remote_transmitter:
  - id: transmitter
    pin:
      number: ${gdo0_pin}
      allow_other_uses: true
    carrier_duty_percent: 100%

remote_receiver:
  - id: receiver
    pin:
      number: ${gdo0_pin}
      allow_other_uses: true
    dump:
      - raw

# TX frequency configuration
number:
  - platform: template
    id: tx_frequency_number
    internal: true
    unit_of_measurement: "MHz"
    min_value: 430.000
    max_value: 440.000
    step: 0.001
    optimistic: true
    initial_value: ${tx_frequency}
    on_value:
      - lambda: |-
          if (id(cc1101_transceiver) != nullptr) {
            get_cc1101(cc1101_transceiver).setFreq(x);
          }

# Reusable transmission scripts
script:
  - id: transmit_generator_start
    mode: single
    then:
      - switch.turn_off: receive_mode
      - lambda: |-
          if (id(cc1101_transceiver) != nullptr) {
            get_cc1101(cc1101_transceiver).setFreq(id(tx_frequency_number).state);
            get_cc1101(cc1101_transceiver).beginTransmission();
          }
      - remote_transmitter.transmit_raw:
          code: !lambda "return id(generator_start_code);"
          repeat:
            times: 3
            wait_time: 15ms

  - id: transmit_generator_stop
    mode: single
    then:
      - switch.turn_off: receive_mode
      - lambda: |-
          if (id(cc1101_transceiver) != nullptr) {
            get_cc1101(cc1101_transceiver).setFreq(id(tx_frequency_number).state);
            get_cc1101(cc1101_transceiver).beginTransmission();
          }
      - remote_transmitter.transmit_raw:
          code: !lambda "return id(generator_stop_code);"
          repeat:
            times: 3
            wait_time: 15ms

# Listen mode toggle - exposed to Home Assistant
switch:
  - platform: template
    name: "Generator RF Listen Mode"
    id: receive_mode
    icon: mdi:radio-tower
    optimistic: true
    turn_on_action:
      - lambda: |-
          if (id(cc1101_transceiver) != nullptr) {
            get_cc1101(cc1101_transceiver).endTransmission();
          }
    turn_off_action:
      - lambda: |-
          // Ensure correct TX frequency
          if (id(cc1101_transceiver) != nullptr) {
            get_cc1101(cc1101_transceiver).setFreq(id(tx_frequency_number).state);
          }
      - lambda: |-
          if (id(cc1101_transceiver) != nullptr) {
            get_cc1101(cc1101_transceiver).beginTransmission();
          }

# Dry contact input for generator control
# When contact closes: send generator start command
# When contact opens: send generator stop command
binary_sensor:
  - platform: gpio
    id: generator_control_contact
    internal: true
    pin:
      number: ${dry_contact_pin}
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      - script.execute: transmit_generator_start
    on_release:
      - script.execute: transmit_generator_stop

# Manual control buttons - exposed to Home Assistant
button:
  - platform: template
    name: "Generator Start"
    id: manual_generator_start
    icon: mdi:play-circle-outline
    on_press:
      - script.execute: transmit_generator_start

  - platform: template
    name: "Generator Stop"
    id: manual_generator_stop
    icon: mdi:stop-circle-outline
    on_press:
      - script.execute: transmit_generator_stop
